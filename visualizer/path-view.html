<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CodeMapper | Path View</title>
    <link rel="stylesheet" href="./styles.css" />
    <link
      rel="stylesheet"
      href="https://esm.sh/reactflow@11.11.1/dist/style.css"
    />
    <style>
      /* Ultra-compact layout styles for path view */
      .react-flow__node {
        min-width: 150px !important;
        max-width: 200px !important;
        font-size: 10px !important;
        min-height: 60px !important;
      }
      .custom-node {
        min-height: 60px !important;
        border-radius: 4px !important;
      }
      .node-header {
        padding: 2px 6px !important;
        font-size: 8px !important;
        font-weight: bold !important;
        line-height: 1.2 !important;
      }
      .node-body {
        padding: 4px 6px !important;
      }
      .node-body .function-name {
        font-size: 10px !important;
        font-weight: 600 !important;
        margin-bottom: 2px !important;
        line-height: 1.2 !important;
      }
      .node-body .file-path {
        font-size: 8px !important;
        margin-top: 2px !important;
        line-height: 1.1 !important;
        opacity: 0.8 !important;
      }
      /* Compact edge styling for Bezier curves */
      .react-flow__edge.n8n-edge .react-flow__edge-path {
        stroke-width: 1px !important; /* Thin lines for path view */
      }
      .react-flow__edge.n8n-edge.highlighted .react-flow__edge-path {
        stroke-width: 2px !important; /* Slightly thicker for highlighted */
      }
      .export-button {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: #ffffff;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .export-button:hover {
        background-color: #218838;
        border-color: #1e7e34;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      .selection-box {
        position: absolute;
        border: 2px dashed #4a9eff;
        background-color: rgba(74, 158, 255, 0.1);
        pointer-events: none;
        z-index: 1000;
        border-radius: 4px;
      }
      .react-flow__node.selected {
        box-shadow: 0 0 0 2px #4a9eff !important;
        transform: scale(1.02);
        transition: all 0.2s ease;
      }
    </style>
    <script
      async
      src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom": "https://esm.sh/react-dom@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "reactflow": "https://esm.sh/reactflow@11.11.1?deps=react@18.2.0,react-dom@18.2.0"
        }
      }
    </script>
  </head>
  <body>
    <div
      id="root"
      style="width: 100vw; height: 100vh; position: relative"
    ></div>
    <button class="export-button" id="exportBtn">ðŸ“· Export PNG</button>
    <script type="module">
      import React, { useState, useCallback, useEffect } from "react";
      import { createRoot } from "react-dom/client";
      import ReactFlow, {
        Controls,
        Background,
        Position,
        Handle,
        MarkerType,
      } from "reactflow";
      import { toPng } from "https://esm.sh/html-to-image@1.11.11";

      const CustomNode = React.memo(({ data, selected }) => {
        return React.createElement(
          "div",
          {
            className: `custom-node ${selected ? "selected" : ""}`,
          },
          React.createElement(Handle, {
            type: "target",
            position: Position.Left,
            isConnectable: false,
            style: { background: "#555" },
          }),
          React.createElement(
            "div",
            { className: "node-header" },
            data.package
          ),
          React.createElement(
            "div",
            { className: "node-body" },
            React.createElement(
              "div",
              { className: "function-name" },
              data.name
            ),
            React.createElement(
              "div",
              { className: "file-path" },
              data.filePath
            )
          ),
          React.createElement(Handle, {
            type: "source",
            position: Position.Right,
            isConnectable: false,
            style: { background: "#555" },
          })
        );
      });

      function getCompactLayout(nodes, edges) {
        // Create a fresh copy of nodes with reset positions
        const nodeMap = new Map(
          nodes.map((n) => [n.id, { ...n, position: { x: 0, y: 0 } }])
        );
        const adjacencyList = new Map();
        const inDegree = new Map();

        // Initialize maps
        nodes.forEach((node) => {
          adjacencyList.set(node.id, []);
          inDegree.set(node.id, 0);
        });

        // Build adjacency list and in-degree count
        edges.forEach((edge) => {
          adjacencyList.get(edge.source).push(edge.target);
          inDegree.set(edge.target, inDegree.get(edge.target) + 1);
        });

        // Topological sort using Kahn's algorithm
        const columns = [];
        let queue = [];

        // Find all nodes with no incoming edges (first column)
        nodes.forEach((node) => {
          if (inDegree.get(node.id) === 0) {
            queue.push(node.id);
          }
        });

        let columnIndex = 0;
        while (queue.length > 0) {
          const currentLevel = [...queue];
          columns[columnIndex] = [];
          queue = [];

          currentLevel.forEach((nodeId) => {
            const node = nodeMap.get(nodeId);
            columns[columnIndex].push(node);

            // Process neighbors
            const neighbors = adjacencyList.get(nodeId) || [];
            neighbors.forEach((neighborId) => {
              const newInDegree = inDegree.get(neighborId) - 1;
              inDegree.set(neighborId, newInDegree);

              if (newInDegree === 0) {
                queue.push(neighborId);
              }
            });
          });

          columnIndex++;
        }

        // Handle any remaining nodes (cycles or isolated nodes)
        const processedNodes = new Set();
        columns.forEach((column) => {
          column.forEach((node) => processedNodes.add(node.id));
        });

        const remainingNodes = nodes.filter(
          (node) => !processedNodes.has(node.id)
        );
        if (remainingNodes.length > 0) {
          columns[columnIndex] = remainingNodes.map((n) => nodeMap.get(n.id));
        }

        // Ultra-compact spacing
        const HORIZONTAL_SPACING = 280;
        const VERTICAL_SPACING = 120;

        // Calculate total height for centering
        const maxColumnHeight = Math.max(...columns.map((col) => col.length));
        const totalHeight = maxColumnHeight * VERTICAL_SPACING;

        // Position nodes with proper left-to-right flow and vertical centering
        columns.forEach((columnNodes, colIndex) => {
          columnNodes.sort((a, b) => a.id.localeCompare(b.id));

          // Calculate vertical offset to center the column
          const columnHeight = columnNodes.length * VERTICAL_SPACING;
          const verticalOffset = (totalHeight - columnHeight) / 2;

          columnNodes.forEach((node, rowIndex) => {
            node.position = {
              x: colIndex * HORIZONTAL_SPACING,
              y: verticalOffset + rowIndex * VERTICAL_SPACING,
            };
          });
        });

        return Array.from(nodeMap.values());
      }

      const nodeTypes = { customNode: CustomNode };
      const defaultEdgeOptions = {
        type: "default",
        className: "n8n-edge highlighted",
        markerEnd: { type: MarkerType.ArrowClosed },
      };

      // Placeholder for dynamic data injection
      let pathNodes = PLACEHOLDER_NODES;
      const pathEdges = PLACEHOLDER_EDGES;
      pathNodes = getCompactLayout(pathNodes, pathEdges);

      function PathView() {
        // Store base nodes without embedding selection flag
        const [nodes, setNodes] = React.useState(
          pathNodes.map((n) => ({ ...n })) // sanitized copy
        );
        const [selectedNodes, setSelectedNodes] = React.useState(new Set());
        const [isSelecting, setIsSelecting] = React.useState(false);
        const [selectionBox, setSelectionBox] = React.useState(null);
        const [selectionStart, setSelectionStart] = React.useState(null);

        const onNodesChange = React.useCallback((changes) => {
          // Only honor position changes; selection handled manually
          setNodes((nds) => {
            const copy = [...nds];
            changes.forEach((ch) => {
              if (ch.type === "position" && ch.position) {
                const i = copy.findIndex((n) => n.id === ch.id);
                if (i !== -1) copy[i] = { ...copy[i], position: ch.position };
              }
            });
            return copy;
          });
        }, []);

        const applySelectionSetToRender = React.useCallback(
          () => nodes.map((n) => ({ ...n, selected: selectedNodes.has(n.id) })),
          [nodes, selectedNodes]
        );

        const toggleSingle = React.useCallback((id) => {
          setSelectedNodes((prev) => {
            const next = new Set(prev);
            if (next.has(id)) next.delete(id);
            else next.add(id);
            return next;
          });
        }, []);

        const onNodeClick = React.useCallback(
          (e, node) => {
            if (e.ctrlKey || e.metaKey) {
              e.stopPropagation();
              toggleSingle(node.id);
            }
          },
          [toggleSingle]
        );

        const onPaneClick = React.useCallback(
          (e) => {
            if (!e.ctrlKey && !e.metaKey) {
              setSelectedNodes(new Set());
            }
          },
          []
        );

        const onSelectionStart = React.useCallback(
          (e) => {
            if (
              (e.ctrlKey || e.metaKey) &&
              e.target.classList.contains("react-flow__pane")
            ) {
              e.preventDefault();
              const root = document.getElementById("root");
              if (!root) return;
              const rect = root.getBoundingClientRect();
              const startX = e.clientX - rect.left;
              const startY = e.clientY - rect.top;
              setIsSelecting(true);
              setSelectionStart({ x: startX, y: startY });
              setSelectionBox({ x: startX, y: startY, width: 0, height: 0 });
            }
          },
          []
        );

        const computeDragSelection = React.useCallback(
          (box, baseSet) => {
            const root = document.getElementById("root");
            if (!root) return baseSet;
            const rootRect = root.getBoundingClientRect();
            const next = new Set(baseSet);
            nodes.forEach((n) => {
              const el = document.querySelector(
                `[data-id="${n.id.replace(/"/g, '\\"')}"]`
              );
              if (!el) return;
              const r = el.getBoundingClientRect();
              const x = r.left - rootRect.left;
              const y = r.top - rootRect.top;
              const w = r.width;
              const h = r.height;
              if (
                x < box.x + box.width &&
                x + w > box.x &&
                y < box.y + box.height &&
                y + h > box.y
              ) {
                next.add(n.id);
              }
            });
            return next;
          },
          [nodes]
        );

        const onSelectionDrag = React.useCallback(
          (e) => {
            if (!isSelecting || !selectionStart) return;
            e.preventDefault();
            const root = document.getElementById("root");
            if (!root) return;
            const rect = root.getBoundingClientRect();
            const curX = e.clientX - rect.left;
            const curY = e.clientY - rect.top;
            const x = Math.min(selectionStart.x, curX);
            const y = Math.min(selectionStart.y, curY);
            const width = Math.abs(curX - selectionStart.x);
            const height = Math.abs(curY - selectionStart.y);
            const box = { x, y, width, height };
            setSelectionBox(box);
            if (width > 4 && height > 4) {
              // Live update additive selection
              setSelectedNodes((prev) => computeDragSelection(box, prev));
            }
          },
          [isSelecting, selectionStart, computeDragSelection]
        );

        const finishSelection = React.useCallback(() => {
          setIsSelecting(false);
          setSelectionBox(null);
          setSelectionStart(null);
        }, []);

        React.useEffect(() => {
          const mm = (e) => {
            if (isSelecting) onSelectionDrag(e);
          };
          const mu = () => {
            if (isSelecting) finishSelection();
          };
          document.addEventListener("mousemove", mm);
          document.addEventListener("mouseup", mu);
          return () => {
            document.removeEventListener("mousemove", mm);
            document.removeEventListener("mouseup", mu);
          };
        }, [isSelecting, onSelectionDrag, finishSelection]);

        return React.createElement(
          "div",
          {
            style: { width: "100%", height: "100%", position: "relative" },
            onMouseDown: onSelectionStart,
          },
          selectionBox &&
            React.createElement("div", {
              className: "selection-box",
              style: {
                left: selectionBox.x + "px",
                top: selectionBox.y + "px",
                width: selectionBox.width + "px",
                height: selectionBox.height + "px",
              },
            }),
          React.createElement(
            ReactFlow,
            {
              nodes: applySelectionSetToRender(),
              edges: pathEdges,
              onNodesChange: onNodesChange,
              nodeTypes: nodeTypes,
              onNodeClick: onNodeClick,
              onPaneClick: onPaneClick,
              fitView: true,
              fitViewOptions: { padding: 0.15, maxZoom: 1.0, minZoom: 0.3 },
              defaultEdgeOptions: defaultEdgeOptions,
              nodesDraggable: true,
              nodesConnectable: false,
              elementsSelectable: false,
              selectNodesOnDrag: false,
              proOptions: { hideAttribution: true },
              minZoom: 0.1,
              maxZoom: 3,
            },
            React.createElement(Controls),
            React.createElement(Background, {
              variant: "dots",
              gap: 12,
              size: 1,
            })
          )
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(
        React.createElement(
          React.StrictMode,
          null,
          React.createElement(PathView)
        )
      );

      // Enhanced export button handler with improved quality
      document.getElementById("exportBtn").onclick = function () {
        const viewport = document.querySelector(".react-flow__viewport");
        if (!viewport) return;

        // Calculate dimensions for high DPI
        const pixelRatio = window.devicePixelRatio || 2;
        const width = viewport.scrollWidth * pixelRatio;
        const height = viewport.scrollHeight * pixelRatio;

        toPng(viewport, {
          backgroundColor: "#1a192b",
          width: width,
          height: height,
          pixelRatio: pixelRatio,
          quality: 1.0,
          canvasWidth: width,
          canvasHeight: height,
          style: {
            transform: "scale(" + pixelRatio + ")",
            transformOrigin: "top left",
          },
        })
          .then((dataUrl) => {
            const link = document.createElement("a");
            link.download = "codemapper-path-hq.png";
            link.href = dataUrl;
            link.click();
          })
          .catch((err) => {
            console.error("Failed to export PNG:", err);
          });
      };
    </script>
  </body>
</html>
              style: {
                left: selectionBox.x + "px",
                top: selectionBox.y + "px",
                width: selectionBox.width + "px",
                height: selectionBox.height + "px",
              },
            }),
          React.createElement(
            ReactFlow,
            {
              nodes: nodes,
              edges: pathEdges,
              onNodesChange: onNodesChange,
              nodeTypes: nodeTypes,
              onNodeClick: onNodeClick,
              onPaneClick: onPaneClick,
              fitView: true,
              fitViewOptions: { padding: 0.15, maxZoom: 1.0, minZoom: 0.3 },
              defaultEdgeOptions: defaultEdgeOptions,
              nodesDraggable: true,
              nodesConnectable: false,
              elementsSelectable: false,
              selectNodesOnDrag: false,
              proOptions: { hideAttribution: true },
              minZoom: 0.1,
              maxZoom: 3,
            },
            React.createElement(Controls),
            React.createElement(Background, {
              variant: "dots",
              gap: 12,
              size: 1,
            })
          )
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(
        React.createElement(
          React.StrictMode,
          null,
          React.createElement(PathView)
        )
      );

      // Enhanced export button handler with improved quality
      document.getElementById("exportBtn").onclick = function () {
        const viewport = document.querySelector(".react-flow__viewport");
        if (!viewport) return;

        // Calculate dimensions for high DPI
        const pixelRatio = window.devicePixelRatio || 2;
        const width = viewport.scrollWidth * pixelRatio;
        const height = viewport.scrollHeight * pixelRatio;

        toPng(viewport, {
          backgroundColor: "#1a192b",
          width: width,
          height: height,
          pixelRatio: pixelRatio,
          quality: 1.0,
          canvasWidth: width,
          canvasHeight: height,
          style: {
            transform: "scale(" + pixelRatio + ")",
            transformOrigin: "top left",
          },
        })
          .then((dataUrl) => {
            const link = document.createElement("a");
            link.download = "codemapper-path-hq.png";
            link.href = dataUrl;
            link.click();
          })
          .catch((err) => {
            console.error("Failed to export PNG:", err);
          });
      };
    </script>
  </body>
</html>
