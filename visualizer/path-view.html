<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CodeMapper | Path View</title>
    <link rel="stylesheet" href="./styles.css" />
    <link
      rel="stylesheet"
      href="https://esm.sh/reactflow@11.11.1/dist/style.css"
    />
    <style>
      /* Ultra-compact layout styles for path view */
      .react-flow__node {
        min-width: 150px !important;
        max-width: 200px !important;
        font-size: 10px !important;
        min-height: 60px !important;
      }
      .custom-node {
        min-height: 60px !important;
        border-radius: 4px !important;
      }
      .node-header {
        padding: 2px 6px !important;
        font-size: 8px !important;
        font-weight: bold !important;
        line-height: 1.2 !important;
      }
      .node-body {
        padding: 4px 6px !important;
      }
      .node-body .function-name {
        font-size: 10px !important;
        font-weight: 600 !important;
        margin-bottom: 2px !important;
        line-height: 1.2 !important;
      }
      .node-body .file-path {
        font-size: 8px !important;
        margin-top: 2px !important;
        line-height: 1.1 !important;
        opacity: 0.8 !important;
      }
      /* Compact edge styling for Bezier curves */
      .react-flow__edge.n8n-edge .react-flow__edge-path {
        stroke-width: 1px !important; /* Thin lines for path view */
      }
      .react-flow__edge.n8n-edge.highlighted .react-flow__edge-path {
        stroke-width: 2px !important; /* Slightly thicker for highlighted */
      }
      .export-button {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        background-color: #28a745;
        border: 1px solid #28a745;
        color: #ffffff;
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }
      .export-button:hover {
        background-color: #218838;
        border-color: #1e7e34;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      .selection-box {
        position: absolute;
        border: 2px dashed #4a9eff;
        background-color: rgba(74, 158, 255, 0.1);
        pointer-events: none;
        z-index: 1000;
        border-radius: 4px;
      }
      .react-flow__node.selected {
        box-shadow: 0 0 0 2px #4a9eff !important;
        transform: scale(1.02);
        transition: all 0.2s ease;
      }
    </style>
    <script
      async
      src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"
    ></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react-dom": "https://esm.sh/react-dom@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "reactflow": "https://esm.sh/reactflow@11.11.1?deps=react@18.2.0,react-dom@18.2.0"
        }
      }
    </script>
  </head>
  <body>
    <div
      id="root"
      style="width: 100vw; height: 100vh; position: relative"
    ></div>
    <button class="export-button" id="exportBtn">ðŸ“· Export PNG</button>
    <script type="module">
      import React, { useState, useCallback, useEffect } from "react";
      import { createRoot } from "react-dom/client";
      import ReactFlow, {
        Controls,
        Background,
        Position,
        Handle,
        MarkerType,
      } from "reactflow";
      import { toPng } from "https://esm.sh/html-to-image@1.11.11";

      const CustomNode = React.memo(({ data, selected }) => {
        return React.createElement(
          "div",
          {
            className: `custom-node ${selected ? "selected" : ""}`,
          },
          React.createElement(Handle, {
            type: "target",
            position: Position.Left,
            isConnectable: false,
            style: { background: "#555" },
          }),
          React.createElement(
            "div",
            { className: "node-header" },
            data.package
          ),
          React.createElement(
            "div",
            { className: "node-body" },
            React.createElement(
              "div",
              { className: "function-name" },
              data.name
            ),
            React.createElement(
              "div",
              { className: "file-path" },
              data.filePath
            )
          ),
          React.createElement(Handle, {
            type: "source",
            position: Position.Right,
            isConnectable: false,
            style: { background: "#555" },
          })
        );
      });

      function getCompactLayout(nodes, edges) {
        // Create a fresh copy of nodes with reset positions
        const nodeMap = new Map(
          nodes.map((n) => [n.id, { ...n, position: { x: 0, y: 0 } }])
        );
        const adjacencyList = new Map();
        const inDegree = new Map();

        // Initialize maps
        nodes.forEach((node) => {
          adjacencyList.set(node.id, []);
          inDegree.set(node.id, 0);
        });

        // Build adjacency list and in-degree count
        edges.forEach((edge) => {
          adjacencyList.get(edge.source).push(edge.target);
          inDegree.set(edge.target, inDegree.get(edge.target) + 1);
        });

        // Topological sort using Kahn's algorithm
        const columns = [];
        let queue = [];

        // Find all nodes with no incoming edges (first column)
        nodes.forEach((node) => {
          if (inDegree.get(node.id) === 0) {
            queue.push(node.id);
          }
        });

        let columnIndex = 0;
        while (queue.length > 0) {
          const currentLevel = [...queue];
          columns[columnIndex] = [];
          queue = [];

          currentLevel.forEach((nodeId) => {
            const node = nodeMap.get(nodeId);
            columns[columnIndex].push(node);

            // Process neighbors
            const neighbors = adjacencyList.get(nodeId) || [];
            neighbors.forEach((neighborId) => {
              const newInDegree = inDegree.get(neighborId) - 1;
              inDegree.set(neighborId, newInDegree);

              if (newInDegree === 0) {
                queue.push(neighborId);
              }
            });
          });

          columnIndex++;
        }

        // Handle any remaining nodes (cycles or isolated nodes)
        const processedNodes = new Set();
        columns.forEach((column) => {
          column.forEach((node) => processedNodes.add(node.id));
        });

        const remainingNodes = nodes.filter(
          (node) => !processedNodes.has(node.id)
        );
        if (remainingNodes.length > 0) {
          columns[columnIndex] = remainingNodes.map((n) => nodeMap.get(n.id));
        }

        // Ultra-compact spacing
        const HORIZONTAL_SPACING = 280;
        const VERTICAL_SPACING = 120;

        // Calculate total height for centering
        const maxColumnHeight = Math.max(...columns.map((col) => col.length));
        const totalHeight = maxColumnHeight * VERTICAL_SPACING;

        // Position nodes with proper left-to-right flow and vertical centering
        columns.forEach((columnNodes, colIndex) => {
          columnNodes.sort((a, b) => a.id.localeCompare(b.id));

          // Calculate vertical offset to center the column
          const columnHeight = columnNodes.length * VERTICAL_SPACING;
          const verticalOffset = (totalHeight - columnHeight) / 2;

          columnNodes.forEach((node, rowIndex) => {
            node.position = {
              x: colIndex * HORIZONTAL_SPACING,
              y: verticalOffset + rowIndex * VERTICAL_SPACING,
            };
          });
        });

        return Array.from(nodeMap.values());
      }

      const nodeTypes = { customNode: CustomNode };
      const defaultEdgeOptions = {
        type: "default",
        className: "n8n-edge highlighted",
        markerEnd: { type: MarkerType.ArrowClosed },
      };

      // Placeholder for dynamic data injection
      let pathNodes = PLACEHOLDER_NODES;
      const pathEdges = PLACEHOLDER_EDGES;
      pathNodes = getCompactLayout(pathNodes, pathEdges);

      function PathView() {
        const [selectedNodes, setSelectedNodes] = React.useState(new Set());
        const [isSelecting, setIsSelecting] = React.useState(false);
        const [selectionBox, setSelectionBox] = React.useState(null);
        const [selectionStart, setSelectionStart] = React.useState(null);
        const [nodes, setNodes] = React.useState(
          pathNodes.map((node) => ({
            ...node,
            selected: false,
          }))
        );

        const onNodesChange = React.useCallback((changes) => {
          setNodes((nds) => {
            const updatedNodes = [...nds];
            changes.forEach((change) => {
              const nodeIndex = updatedNodes.findIndex(
                (n) => n.id === change.id
              );
              if (nodeIndex !== -1) {
                if (change.type === "position" && change.position) {
                  updatedNodes[nodeIndex] = {
                    ...updatedNodes[nodeIndex],
                    position: change.position,
                  };
                } else if (change.type === "select") {
                  updatedNodes[nodeIndex] = {
                    ...updatedNodes[nodeIndex],
                    selected: change.selected,
                  };
                }
              }
            });
            return updatedNodes;
          });
        }, []);

        const onNodeClick = useCallback((event, node) => {
          if (event.ctrlKey || event.metaKey) {
            event.stopPropagation();
            setSelectedNodes((prev) => {
              const newSet = new Set(prev);
              if (newSet.has(node.id)) {
                newSet.delete(node.id);
              } else {
                newSet.add(node.id);
              }

              // Update node selected state immediately
              setNodes((nds) =>
                nds.map((n) => ({
                  ...n,
                  selected: newSet.has(n.id),
                }))
              );

              return newSet;
            });
          }
        }, []);

        const onPaneClick = useCallback((event) => {
          if (!event.ctrlKey && !event.metaKey) {
            setSelectedNodes(new Set());
            setNodes((nds) => nds.map((n) => ({ ...n, selected: false })));
          }
        }, []);

        const onSelectionStart = useCallback((event) => {
          if (
            (event.ctrlKey || event.metaKey) &&
            event.target.classList.contains("react-flow__pane")
          ) {
            event.preventDefault();
            event.stopPropagation();
            const rootElement = document.getElementById("root");
            if (!rootElement) return;

            const rect = rootElement.getBoundingClientRect();
            const startX = event.clientX - rect.left;
            const startY = event.clientY - rect.top;

            setIsSelecting(true);
            setSelectionStart({ x: startX, y: startY });
            setSelectionBox({ x: startX, y: startY, width: 0, height: 0 });
          }
        }, []);

        const onSelectionDrag = useCallback(
          (event) => {
            if (isSelecting && selectionStart) {
              event.preventDefault();
              event.stopPropagation();
              const rootElement = document.getElementById("root");
              if (!rootElement) return;

              const rect = rootElement.getBoundingClientRect();
              const currentX = event.clientX - rect.left;
              const currentY = event.clientY - rect.top;

              const x = Math.min(selectionStart.x, currentX);
              const y = Math.min(selectionStart.y, currentY);
              const width = Math.abs(currentX - selectionStart.x);
              const height = Math.abs(currentY - selectionStart.y);

              setSelectionBox({ x, y, width, height });

              // Real-time selection highlighting during drag
              if (width > 5 && height > 5) {
                const selectedNodeIds = new Set(selectedNodes); // Keep existing selections
                const rootRect = rootElement.getBoundingClientRect();

                nodes.forEach((node) => {
                  const nodeElement = document.querySelector(
                    `[data-id="${node.id.replace(/"/g, '\\"')}"]`
                  );
                  if (nodeElement) {
                    const nodeRect = nodeElement.getBoundingClientRect();
                    const nodeX = nodeRect.left - rootRect.left;
                    const nodeY = nodeRect.top - rootRect.top;
                    const nodeWidth = nodeRect.width;
                    const nodeHeight = nodeRect.height;

                    const nodeRight = nodeX + nodeWidth;
                    const nodeBottom = nodeY + nodeHeight;
                    const selectionRight = x + width;
                    const selectionBottom = y + height;

                    if (
                      nodeX < selectionRight &&
                      nodeRight > x &&
                      nodeY < selectionBottom &&
                      nodeBottom > y
                    ) {
                      selectedNodeIds.add(node.id);
                    }
                  }
                });

                // Update visual selection in real-time
                setNodes((nds) =>
                  nds.map((n) => ({
                    ...n,
                    selected: selectedNodeIds.has(n.id),
                  }))
                );
              }
            }
          },
          [isSelecting, selectionStart, selectedNodes, nodes]
        );

        const onSelectionEnd = useCallback(() => {
          if (
            isSelecting &&
            selectionBox &&
            selectionBox.width > 5 &&
            selectionBox.height > 5
          ) {
            const selectedNodeIds = new Set(selectedNodes); // Keep existing selections
            const rootElement = document.getElementById("root");

            if (rootElement) {
              const rootRect = rootElement.getBoundingClientRect();

              nodes.forEach((node) => {
                const nodeElement = document.querySelector(
                  `[data-id="${node.id.replace(/"/g, '\\"')}"]`
                );
                if (nodeElement) {
                  const nodeRect = nodeElement.getBoundingClientRect();
                  const nodeX = nodeRect.left - rootRect.left;
                  const nodeY = nodeRect.top - rootRect.top;
                  const nodeWidth = nodeRect.width;
                  const nodeHeight = nodeRect.height;

                  const nodeRight = nodeX + nodeWidth;
                  const nodeBottom = nodeY + nodeHeight;
                  const selectionRight = selectionBox.x + selectionBox.width;
                  const selectionBottom = selectionBox.y + selectionBox.height;

                  if (
                    nodeX < selectionRight &&
                    nodeRight > selectionBox.x &&
                    nodeY < selectionBottom &&
                    nodeBottom > selectionBox.y
                  ) {
                    selectedNodeIds.add(node.id);
                  }
                }
              });

              setSelectedNodes(selectedNodeIds);

              // Update final node selected state
              setNodes((nds) =>
                nds.map((n) => ({
                  ...n,
                  selected: selectedNodeIds.has(n.id),
                }))
              );
            }
          }

          setIsSelecting(false);
          setSelectionBox(null);
          setSelectionStart(null);
        }, [isSelecting, selectionBox, selectedNodes, nodes]);

        React.useEffect(() => {
          const handleMouseMove = (event) => {
            if (isSelecting) {
              onSelectionDrag(event);
            }
          };

          const handleMouseUp = (event) => {
            if (isSelecting) {
              onSelectionEnd();
            }
          };

          if (isSelecting) {
            document.addEventListener("mousemove", handleMouseMove);
            document.addEventListener("mouseup", handleMouseUp);
          }

          return () => {
            document.removeEventListener("mousemove", handleMouseMove);
            document.removeEventListener("mouseup", handleMouseUp);
          };
        }, [isSelecting, onSelectionDrag, onSelectionEnd]);

        return React.createElement(
          "div",
          {
            style: { width: "100%", height: "100%", position: "relative" },
            onMouseDown: onSelectionStart,
          },
          selectionBox &&
            React.createElement("div", {
              className: "selection-box",
              style: {
                left: selectionBox.x + "px",
                top: selectionBox.y + "px",
                width: selectionBox.width + "px",
                height: selectionBox.height + "px",
              },
            }),
          React.createElement(
            ReactFlow,
            {
              nodes: nodes,
              edges: pathEdges,
              onNodesChange: onNodesChange,
              nodeTypes: nodeTypes,
              onNodeClick: onNodeClick,
              onPaneClick: onPaneClick,
              fitView: true,
              fitViewOptions: { padding: 0.15, maxZoom: 1.0, minZoom: 0.3 },
              defaultEdgeOptions: defaultEdgeOptions,
              nodesDraggable: true,
              nodesConnectable: false,
              elementsSelectable: false,
              selectNodesOnDrag: false,
              proOptions: { hideAttribution: true },
              minZoom: 0.1,
              maxZoom: 3,
            },
            React.createElement(Controls),
            React.createElement(Background, {
              variant: "dots",
              gap: 12,
              size: 1,
            })
          )
        );
      }

      const root = createRoot(document.getElementById("root"));
      root.render(
        React.createElement(
          React.StrictMode,
          null,
          React.createElement(PathView)
        )
      );

      // Enhanced export button handler with improved quality
      document.getElementById("exportBtn").onclick = function () {
        const viewport = document.querySelector(".react-flow__viewport");
        if (!viewport) return;

        // Calculate dimensions for high DPI
        const pixelRatio = window.devicePixelRatio || 2;
        const width = viewport.scrollWidth * pixelRatio;
        const height = viewport.scrollHeight * pixelRatio;

        toPng(viewport, {
          backgroundColor: "#1a192b",
          width: width,
          height: height,
          pixelRatio: pixelRatio,
          quality: 1.0,
          canvasWidth: width,
          canvasHeight: height,
          style: {
            transform: "scale(" + pixelRatio + ")",
            transformOrigin: "top left",
          },
        })
          .then((dataUrl) => {
            const link = document.createElement("a");
            link.download = "codemapper-path-hq.png";
            link.href = dataUrl;
            link.click();
          })
          .catch((err) => {
            console.error("Failed to export PNG:", err);
          });
      };
    </script>
  </body>
</html>
